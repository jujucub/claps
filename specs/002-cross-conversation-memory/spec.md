# Feature Specification: チャネル横断メモリシステム

**Feature Branch**: `002-cross-conversation-memory`
**Created**: 2026-02-21
**Status**: Draft
**Input**: User description: "チャネル横断的なメモリ戦略を実装する。SlackやLINEを横断して共通のメモリを持ち、スレッドをまたいでの共通の記憶を実現する階層的メモリシステム。"

## User Scenarios & Testing *(mandatory)*

### User Story 1 - チャネル横断での記憶共有 (Priority: P1)

ユーザーがSlackでプロジェクトAについて指示した内容を、
後日LINEから確認・参照できるようにしたい。
現状ではSlackのスレッドで話した内容はLINEからアクセスできず、
同じ説明を繰り返す必要がある。
チャネルを切り替えても、システムが過去のやり取りの要点を
記憶として保持し、適切に参照できることが求められる。

**Why this priority**: マルチチャネル対応の根幹となる機能であり、
これがなければチャネル間の連携が実現できない。
依頼書で最も強く要望されている中核機能である。

**Independent Test**: Slackでプロジェクトに関する指示を出した後、
LINEから「さっきの指示内容を教えて」と聞いて
正しく回答が返ることで検証できる。

**Acceptance Scenarios**:

1. **Given** ユーザーがSlackでプロジェクトAについて指示を出している,
   **When** 同一ユーザーがLINEから「プロジェクトAの状況は？」と質問する,
   **Then** Slackで指示した内容の要点が回答に反映される
2. **Given** ユーザーがLINEで設計方針を決定している,
   **When** 同一ユーザーがSlackスレッドから関連する質問をする,
   **Then** LINEで決定した方針が記憶として参照され、
   一貫性のある回答が返される
3. **Given** メモリが存在しない新規ユーザーの初回対話,
   **When** ユーザーがいずれかのチャネルで対話を開始する,
   **Then** 新規プロジェクトのメモリ領域が自動的に作成され、
   対話内容が記録される

---

### User Story 2 - プロジェクト単位のメモリルーティング (Priority: P2)

ユーザーが複数のプロジェクトについて対話する際、
システムが会話の文脈からどのプロジェクトに関する話題かを判断し、
適切なプロジェクトのメモリを自動的にロードしたい。
また、会話中に別プロジェクトの内容が言及された場合は、
そのプロジェクトのメモリにもアクセスできるようにしたい。

**Why this priority**: メモリが蓄積されるほど、適切なメモリを
選択・ロードする仕組みが重要になる。
全メモリをロードするとコンテキストが溢れるため、
ルーティングはメモリシステムの実用性を左右する。

**Independent Test**: 異なるプロジェクトA・Bについて交互に対話し、
各プロジェクト固有の情報が混同されずに正しくロードされること、
また「プロジェクトBのあの実装を参考にしたい」と言った際に
プロジェクトBのメモリが追加でロードされることで検証できる。

**Acceptance Scenarios**:

1. **Given** プロジェクトAとBのメモリが蓄積されている,
   **When** ユーザーがプロジェクトAについて質問する,
   **Then** プロジェクトAのメモリのみがロードされ、
   プロジェクトBの情報は混入しない
2. **Given** プロジェクトAについて対話中,
   **When** ユーザーが「プロジェクトBのあの実装を参考にしたい」と発言する,
   **Then** プロジェクトBのメモリが追加でロードされ、
   両プロジェクトの情報を組み合わせた回答が返される
3. **Given** 既存のどのプロジェクトにも該当しない話題,
   **When** ユーザーが新しいプロジェクトについて対話を始める,
   **Then** 新規プロジェクト名が自動決定され、
   メモリ領域が作成される

---

### User Story 3 - メモリの概要化とライフサイクル管理 (Priority: P3)

長期間の利用によりメモリが膨大になっても、
システムが自動的に古い記憶を概要化し、
コンテキストウィンドウを圧迫しないようにしたい。
一方で、ユーザーが「これは覚えておいて」と明示的に指示した内容や、
プロジェクトにとって不可欠な情報は、概要化されずに
詳細な形で保持されてほしい。

**Why this priority**: メモリが蓄積されるとコンテキストウィンドウの制約に
直面するため、概要化と選択的保持は長期運用に不可欠である。
ただし、US1・US2が機能しない状態では
概要化の前提となるメモリ自体が存在しない。

**Independent Test**: 大量の対話を行った後でも応答速度と品質が
維持されること、かつ「覚えておいて」と指示した内容が
詳細な形で参照可能であることで検証できる。

**Acceptance Scenarios**:

1. **Given** プロジェクトのメモリが一定容量を超えている,
   **When** システムが概要化処理を実行する,
   **Then** 古い記憶が要約に変換され、メモリ全体のサイズが縮小される。
   概要化後も主要な事実と決定事項は参照可能である
2. **Given** ユーザーが「これを覚えておいて: APIキーの形式はXXX」と発言,
   **When** 後日同じプロジェクトについて対話する,
   **Then** 「APIキーの形式はXXX」が概要化されずに
   そのままの詳細度で参照される
3. **Given** メモリ注入後のプロンプトがコンテキスト上限に近い,
   **When** 新しい対話が開始される,
   **Then** 注入するメモリ量が自動的に調整され、
   コンテキストウィンドウが溢れることなく対話が成立する

---

### User Story 4 - スレッド横断でのメモリ共有 (Priority: P4)

同じチャネル内でも、スレッドが変わるとコンテキストが
リセットされてしまう問題を解消したい。
同一プロジェクトに関するSlackの複数スレッドの対話内容が
共通のメモリに集約され、新しいスレッドを開始しても
過去のスレッドで得た知識が引き継がれるようにしたい。

**Why this priority**: チャネル横断（US1）と同じ基盤を利用するが、
同一チャネル内のスレッド間共有はUS1の派生であり、
メモリの格納・検索の仕組みが確立した後に
自然に実現できる機能である。

**Independent Test**: Slackの異なるスレッドで同じプロジェクトについて
対話し、前のスレッドで伝えた情報が新しいスレッドでも
参照されることで検証できる。

**Acceptance Scenarios**:

1. **Given** Slackのスレッド1でプロジェクトAの設計を議論済み,
   **When** Slackの別スレッド2で同プロジェクトについて質問する,
   **Then** スレッド1で決定した設計内容が記憶として反映される
2. **Given** 複数スレッドで同じプロジェクトについて対話が進行中,
   **When** それぞれのスレッドで異なる情報が追加される,
   **Then** すべての情報がプロジェクト単位のメモリに統合され、
   いずれのスレッドからも最新の統合情報にアクセスできる

---

### Edge Cases

- メモリの保存先ディスクが満杯になった場合、
  エラーを通知し、メモリの書き込みに失敗しても
  対話自体は継続できなければならない
- 同一ユーザーが同時に複数のチャネルから同じプロジェクトの
  メモリを更新しようとした場合、データの競合を検出し、
  後勝ちまたはマージで整合性を保つ
- ルーティング時にプロジェクトの推定が曖昧な場合
  （複数プロジェクトに該当しうる発言）、
  最も関連度の高いプロジェクトを選択し、
  ユーザーに確認を求める手段を提供する
- メモリファイルが外部から手動で編集・破損された場合、
  読み取りエラーを通知しつつ、メモリなしでの対話を継続する
- 概要化処理中にシステムが停止した場合、
  概要化前のメモリを復元可能とする

## Requirements *(mandatory)*

### Functional Requirements

- **FR-001**: システムは、すべてのチャネル（Slack、LINE等）での
  対話内容をプロジェクト単位のメモリとして永続化しなければならない
- **FR-002**: メモリは
  `~/.claps/memory/{abstract-category}/{concrete-category}/{project}/`
  の階層構造で管理しなければならない。
  記憶の内容に基づき、上位ほど抽象的な概念、
  下位ほど具体的な概念で階層化する
  （例: `development/backend/auth-service/`）
- **FR-003**: 各プロジェクトディレクトリには
  セッション単位のメモリファイル `MEMORY_<session_id>.md` を
  配置しなければならない。プロジェクトの概要・目次を
  担う `MEMORY.md` も併設し、短く簡潔に記載する。
  `MEMORY.md` 内にも関連する Session ID を記載し、
  任意のチャネルからセッションを復帰可能にする
- **FR-004**: 詳細な情報（重要な決定事項、ユーザー明示指示等）は
  同ディレクトリ内の個別ファイルに保存しなければならない。
  プラットフォーム固有の情報（Slackスレッド ID、
  LINE グループ ID 等）はセッションメモリファイル
  （`MEMORY_<session_id>.md`）内に記載し、
  セッション復帰時に参照可能とする
- **FR-005**: メモリのディレクトリ階層はチャネル非依存で
  あり、記憶の内容（ドメイン・トピック）に基づいて
  構成しなければならない。SlackやLINEといった
  チャネルの区別はディレクトリ構造に
  影響を与えてはならない
- **FR-006**: 会話の文脈から該当するカテゴリ階層
  （抽象カテゴリ → 具体カテゴリ）およびプロジェクトを推定し、
  適切なメモリをロードするルーティング機構を
  実装しなければならない
- **FR-007**: ルーティング機構は既存のカテゴリ階層と
  プロジェクト一覧を走査し、最も適切なパスを選択
  しなければならない。該当するカテゴリまたはプロジェクトが
  存在しない場合は新規ディレクトリ階層を作成しなければならない
- **FR-008**: 対話中に現在のプロジェクトとは異なるプロジェクトが
  言及された場合、そのプロジェクトのメモリにも
  アクセスするパスを提供しなければならない
- **FR-009**: メモリ内容はタスク完了時（Claude CLIの実行結果が
  返った時点）に更新しなければならない。
  既存のタスク実行パイプラインの結果通知フェーズに
  メモリ更新処理を組み込む
- **FR-010**: プロジェクトの `MEMORY.md` および
  `MEMORY_<session_id>.md` ファイル群の合計サイズが
  コンテキストウィンドウの10%を超えた場合、
  古い情報を概要化して情報量を圧縮しなければならない。
  閾値は憲章の技術的制約に準拠する
- **FR-011**: ユーザーが明示的に「覚えておいて」と指示した内容は
  専用ファイルに保存し、概要化の対象から
  除外しなければならない
- **FR-012**: メモリをClaude CLIのプロンプトに注入する際、
  コンテキストウィンドウの使用量を監視し、
  設定可能な上限を超えないよう制御しなければならない
- **FR-013**: メモリの更新は非破壊的に行い、
  更新前の状態を復元可能とする仕組みを備えなければならない
- **FR-014**: プロジェクト名は人間が判読可能かつ
  一意でなければならない
- **FR-015**: メモリの作成・更新・概要化・ルーティング結果は
  既存の作業履歴ストア（`WorkHistoryRecord`）に
  イベントとして記録しなければならない。
  内省エンジンがメモリ活動を分析対象に含められるようにする

### Key Entities

- **Category**: メモリ階層の中間ノード。
  抽象カテゴリ（例: `development`）と
  具体カテゴリ（例: `backend`）の 2 階層で構成される。
  記憶の内容・ドメインに基づいて分類される
- **Project**: カテゴリ配下のメモリ最下位単位。
  一意のプロジェクト名を持ち、
  関連するすべてのメモリファイルを内包する。
  プロジェクトは複数のチャネル・スレッドの対話から
  横断的に記憶を収集する
- **MEMORY.md**: プロジェクトの記憶の目次・概要ファイル。
  詳細ファイルおよび関連セッション ID への参照を含む。
  コンテキストウィンドウを圧迫しない短い形式
- **SessionMemory** (`MEMORY_<session_id>.md`):
  Claude CLI セッションに紐づくメモリファイル。
  対話の経緯、プラットフォーム固有情報（Slack スレッド ID、
  LINE グループ ID 等）、セッション復帰に必要な情報を含む。
  任意のチャネルからセッションを復帰可能にする
- **DetailFile**: 重要な決定事項、ユーザー明示指示、
  技術的メモなどの詳細情報を保持するファイル。
  `MEMORY.md` から参照される
- **PinnedMemory**: ユーザーが「覚えておいて」と明示指示した
  内容を保持する専用ファイル。概要化の対象外
- **MemoryRouter**: 会話の文脈からカテゴリ階層および
  プロジェクトを推定し、適切なメモリディレクトリへの
  パスを決定するコンポーネント

### Assumptions

- CLAPSは1インスタンス=1ユーザーの運用形態を前提とする。
  メモリにユーザーレベルの分離は設けず、
  すべてのプロジェクトメモリはインスタンス全体で共有される
- ユーザー識別は既存の認証基盤
  （Slack ID、LINE ID等からのユーザーマッピング）を利用する
- メモリの保存先はローカルファイルシステム
  （`~/.claps/memory/`）とし、外部データベースは使用しない
- カテゴリ階層およびプロジェクトの推定には
  Claude CLIを利用する（軽量なプロンプトによる分類）
- 概要化のトリガーはプロジェクト内メモリファイル群の
  合計サイズがコンテキストウィンドウの10%を超えた場合とする
- セッション単位のメモリファイルは Claude CLI の
  セッション ID と対応し、`--resume` フラグによる
  セッション復帰と連動する
- 同時アクセスの競合はファイルロック等の簡易な排他制御で対応する
- 既存のセッション管理（`src/session/store.ts`）は
  短期的なセッション継続用として併存し、
  メモリシステムは長期的な知識蓄積を担う

## Clarifications

### Session 2026-02-21

- Q: メモリの所有モデル（ユーザーごと分離 vs 共有）→ A: 1インスタンス=1ユーザー運用のため、ユーザーレベルの分離は不要。プロジェクト単位のフラット構造で管理する
- Q: メモリ更新のタイミング → A: タスク完了時（Claude CLI実行結果が返った時点）に書き込む。既存パイプラインの結果通知フェーズに統合する
- Q: 概要化のトリガー閾値 → A: MEMORY.md 単体のサイズがコンテキストウィンドウの10%を超えた場合に発動。憲章の技術的制約と連動
- Q: メモリ操作の観測可能性 → A: 既存の作業履歴ストア（WorkHistoryRecord）にメモリイベント（作成・更新・概要化・ルーティング結果）を統合記録する

### Session 2026-02-25 (PR #20 レビュー反映)

- Q: ディレクトリ階層をチャネル別（Slack/LINE）にするか、内容別にするか → A: チャネルを意味する構造は廃止。記憶の内容に基づく「抽象カテゴリ → 具体カテゴリ → Project」の階層に変更。上位ほど抽象的、下位ほど具体的（PR #20 jujucub コメント）
- Q: メモリファイルの単位 → A: プロジェクトごとの `MEMORY.md`（目次・概要）に加え、セッション単位の `MEMORY_<session_id>.md` を導入。MEMORY.md 内にも Session ID を記載し、任意のチャネルからセッション復帰可能にする
- Q: プラットフォーム固有情報の扱い → A: 最下層のセッションメモリファイル内にプラットフォーム固有情報（Slack スレッド ID 等）を記載。Claude CLI のセッションを記憶することで、どのプラットフォームからでも同じコンテキストで復帰可能

## Success Criteria *(mandatory)*

### Measurable Outcomes

- **SC-001**: Slackで伝えた情報をLINEから確認した際、
  80%以上のケースで正確に内容が再現される
- **SC-002**: プロジェクトの自動推定精度が90%以上である
  （ユーザーが意図したプロジェクトのメモリが
  正しくロードされる割合）
- **SC-003**: メモリ概要化後も、主要な決定事項の参照精度が
  95%以上維持される
- **SC-004**: メモリ注入によるプロンプトの増加が
  コンテキストウィンドウの設定上限内に収まり、
  対話の応答品質が劣化しない
- **SC-005**: 「覚えておいて」と指示した内容が、
  30日後も詳細な形で100%参照可能である
- **SC-006**: 100件以上のプロジェクトメモリが蓄積された状態でも、
  メモリのロードとルーティングが
  ユーザーの対話体験を阻害しない応答時間で完了する
